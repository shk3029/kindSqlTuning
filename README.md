# 친절한 SQL 튜닝 (2019/2/17 ~)
### 1장 SQL 파싱과 최적화
1.1 SQL 파싱과 최적화
- 구조적, 집합적, 선언적 질의 언어
  - SQL(Structured Query Language)
  ~~~
  에제) 부서번호(deptno)로 조인해서 사원명 순으로 정렬
  SELECT    *
  FROM      EMP E,
            DEPT D
  WHERE     E.DEPTNO = D.DEPTNO
  ORDER BY  ENAME
  ~~~
  - SQL 최적화 : DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정
- SQL 최적화 과정
  1. SQL 파싱 : SQL을 전달받으면, 가장 먼저 SQL 파서가 파싱을 진행
      - 파싱 트리 생성 : SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
      - Syntax 체크 : 문법적 오류 체크 ex) 누락된 키워드 및 사용할 수 없는 키워드
      - Semantic 체크 : 의미상 오류가 없는지 체크 ex) 존재하지 않는 테이블, 컬럼, 권한
  2. SQL 최적화 : SQL 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후, 가장 효율적인 하나를 선택
  --> 데이터 베이스 성능을 결정하는 가장 핵심적인 엔진 (옵티마이저가 이 역할을 맡음)
  3. 로우 소스 생성 : SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계(로우 소스 생성기가 이 역할을 맡음)
- SQL 옵티마이저
: SQL 옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS 핵심 엔진
  - 옵티마이저 최적화 단계
    1. 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획을 찾음
    2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획 및 예상비용을 산정
    3. 최저 비용을 나타내는 실행계획을 선택
  - 실행계획과 비용
  - 옵티마이저 힌트
  
1.2 SQL 공유 및 재사용
  - 소프트 파싱 vs 하드 파싱
  - 바인드 변수의 중요성

1.3 데이터 저장 구조 및 I/O 메커니즘
  - SQL이 느린 이유
  - 데이터베이스 저장 구조
  - 블록 단위 I/O
  - 시퀀셜 액세스 vs 랜덤 액세스 
  - 논리적 I/O vs 물리적 I/O
  - Single Block I/O vs Multiblock I/O
  - Table Full Scan vs Index Range Scan
  - 캐시 탐색 메커니즘
  











  
